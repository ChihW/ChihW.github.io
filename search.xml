<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>限流那些事（二） -- 如何在spring boot项目中使用限流</title>
    <url>/2020/03/10/%E9%99%90%E6%B5%81%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%BA%8C%EF%BC%89----%E5%A6%82%E4%BD%95%E5%9C%A8spring-boot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在上一篇中， 介绍了限流的一些基本概念以及常见的限流算法， 俗话说：能动手就别哔哔！（(#^.^#)本章将结合实际的项目（<strong>Spring Boot</strong>)来使用限流策略，并且使用注解的方式来进行灵活配置， 本篇做为限流那些事篇二，主要介绍限流在实际项目中的使用。</p>
<a id="more"></a>

<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>​    利用<strong>自定义注解</strong>、<strong>Spring Aop</strong>实现应用级灵活配置的限流…</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>​    新建Spring Boot 工程， 这个很简单， 通过IDEA进行傻瓜式创建…</p>
<h4 id="导入依赖包"><a href="#导入依赖包" class="headerlink" title="导入依赖包"></a>导入依赖包</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// guava</span></span><br><span class="line">compile(<span class="string">"com.google.guava:18.0"</span>)</span><br></pre></td></tr></table></figure>

<p>​    示例项目用的是gradle构建（<em>使用maven构建的话， 引入相应的依赖就行了</em>），这里主要使用的Google Guava提供的RateLimiter工具类。上篇介绍了Google Guava提供的RateLimiter类实现了令牌桶算法。这里说些题外话，本身Google的Guava包里面有非常多且好用的工具类， 下次有时间的话会跟大家一起分享一下Guava包中那些好用的工具类！</p>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shcepp.miniapp.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ChihW</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TbLimiter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每秒向桶中放入令牌的数量   默认最大即不做限流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">perSecond</span><span class="params">()</span> <span class="keyword">default</span> Double.MAX_VALUE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取令牌的等待时间  默认0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeOut</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TimeUnit <span class="title">timeOutUnit</span><span class="params">()</span> <span class="keyword">default</span> TimeUnit.MILLISECONDS</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无法获取令牌返回提示信息 默认值可以自行修改</span></span><br><span class="line">    <span class="function">String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "系统繁忙,请稍后再试."</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    自定义注解中定义了value（<em>令牌数</em>), preSecond(<em>每秒放入的令牌数量</em>)，timeOut(<em>令牌获取超时时间</em>),msg(<em>获取不到令牌返回的错误信息</em>)。注解后面会用到。</p>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shcepp.miniapp.business.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"><span class="keyword">import</span> com.shcepp.miniapp.annotation.TbLimiter;</span><br><span class="line"><span class="keyword">import</span> com.shcepp.miniapp.sys.util.ApiResult;</span><br><span class="line"><span class="keyword">import</span> com.shcepp.miniapp.sys.util.Constants;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.Signature;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by ChihW</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenBucketLimiterAspact</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private final Map&lt;String, RateLimiter&gt; rateLimiters = new ConcurrentHashMap&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RateLimiter rateLimiter = RateLimiter.create(Double.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.LimitSwitch:1&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String limitSwitch;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(@org.springframework.web.bind.annotation.RestController *) &amp;&amp;"</span> +</span><br><span class="line">            <span class="string">"@annotation(com.shcepp.miniapp.annotation.TbLimiter)"</span> +</span><br><span class="line">            <span class="string">"execution(* *(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">controller</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"controller()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">cusAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"拦截到了&#123;&#125;方法..."</span>, pjp.getSignature().getName());</span><br><span class="line">        <span class="comment">// 是否开启限流</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"1"</span>.equals(limitSwitch)) &#123;</span><br><span class="line">            Signature signature = pjp.getSignature();</span><br><span class="line">            MethodSignature methodSignature = (MethodSignature)signature;</span><br><span class="line">            <span class="comment">//获取目标方法</span></span><br><span class="line">            Method targetMethod = methodSignature.getMethod();</span><br><span class="line">            <span class="keyword">if</span> (targetMethod.isAnnotationPresent(TbLimiter<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="comment">//获取目标方法的@TbLimiter注解</span></span><br><span class="line">                TbLimiter lxRateLimit = targetMethod.getAnnotation(TbLimiter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                rateLimiter.setRate(lxRateLimit.perSecond());</span><br><span class="line">                <span class="keyword">if</span> (!rateLimiter.tryAcquire(lxRateLimit.timeOut(), lxRateLimit.timeOutUnit()))</span><br><span class="line">                    <span class="keyword">return</span> ApiResult.newInstance(Constants.CLIENT_FLAG.FLAG_F,</span><br><span class="line">                            Constants.CLIENT_ERROR_900.ERROR_CODE906,</span><br><span class="line">                            lxRateLimit.msg(),</span><br><span class="line">                            <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"controller()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ecsBefore</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//        logger.debug("testBefore");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"controller()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ecsAfter</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//        logger.debug("testAfter");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    使用切面来拦截所有使用了自定义限流注解的方法（<em>@TbLimiter</em>)。获取到注解上的参数进行限流判断，如果超过了限流的阈值， 则直接进行降级操作。</p>
<h4 id="方法限流"><a href="#方法限流" class="headerlink" title="方法限流"></a>方法限流</h4><blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shcepp.miniapp.business.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"Test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/limit"</span>)</span><br><span class="line">    <span class="meta">@TbLimiter</span>(value = <span class="number">2</span>, perSecond = <span class="number">1.0</span>, timeOut = <span class="number">100</span>, msg = <span class="string">"亲,现在流量过大,请稍后再试."</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiResult <span class="title">testLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult(<span class="string">"T"</span>, <span class="string">"200"</span>, <span class="string">"成功"</span>, <span class="string">"OK!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在需要限流的方法上加上<strong>@TbLimiter</strong>注解，设置令牌桶的容量是2个， 每秒放入一个令牌，超时时间为100毫秒（<em>当然这是测试用， 正式使用还是需要根据实际情况进行调整</em>)，然后就可以测试一下限流是否有效果，可以使用postman或者使用jmeter工具测试。</p>
<blockquote>
<p>运行结果(正常执行)</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/10/SEa9BfU1knPCrGl.png" alt="tb_success.png"></p>
<p>​    未超过阈值，可以直接执行！</p>
<blockquote>
<p>运行结果(限流)</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/10/kpVZKYG65DO4XFl.png" alt="tb_error.png"></p>
<p>​    超过阈值，进行限流，正式使用时，可以配置降级方法， 统一管理限流之后的操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    总体来说，本章主要是结合实际项目（<strong>Spring Boot</strong>），来进行限流操作，当然目前介绍的还都是单机版的限流， 也就是在分布式的环境中是不能使用的， 但是可以满足一些比较简单的限流需求， 后面的章节中，我将给大家介绍分布式限流的实现方法，以及如何在接入层做限流。</p>
]]></content>
      <categories>
        <category>限流那些事</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>限流那些事（一） -- what is 限流？</title>
    <url>/2020/03/08/%E9%99%90%E6%B5%81%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E7%AF%87%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流。那么何为限流呢？通俗的解释：限流就是限制流量，这就好比移动每个月送你1G的流量， 用完就就没有了！通过限流，我们可以很好的控制系统的QPS，从而达到保护系统的目的，本篇作为限流那些事开篇， 将会介绍一些常用的限流算法以及各自的特点。</p>
<a id="more"></a>

<h3 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h3><p>​    计数器算法可以算是限流算法里最简单也是最容易实现的一种算法。举个栗子：比如现在有个需求是A接口一分钟的访问次数不能超过100次，那么可以怎么做呢？</p>
<p>​    首先，可以设置一个计数器（<strong>counter</strong>), 每当一个请求过来的时候counter + 1, 然后判断counter的值是否大于100并且该次请求与第一个请求的间隔时间是否在一分钟之内， 如果满足条件，说明请求过多，那么系统就需要给出提交， 例：（网络出现拥堵，请稍微再试）。假如该请求与第一个请求的间隔时间大于1分钟且counter的值还在限流范围内（&lt;100)，那么就需要重置counter，具体算法的示意图如下：</p>
<p><img src="https://i.loli.net/2020/03/08/sEQTgkmw5A9qWoG.jpg" alt="270324-20180926164018551-167363864.jpg"></p>
<p>​    具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> timeStamp = getNowTime();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> reqCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> limit = <span class="number">100</span>; <span class="comment">// 时间窗口内最大请求数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> interval = <span class="number">1000</span>; <span class="comment">// 时间窗口ms</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">grant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = getNowTime();</span><br><span class="line">        <span class="keyword">if</span> (now &lt; timeStamp + interval) &#123;</span><br><span class="line">            <span class="comment">// 在时间窗口内</span></span><br><span class="line">            reqCount++;</span><br><span class="line">            <span class="comment">// 判断当前时间窗口内是否超过最大请求控制数</span></span><br><span class="line">            <span class="keyword">return</span> reqCount &lt;= limit;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeStamp = now;</span><br><span class="line">            <span class="comment">// 超时后重置</span></span><br><span class="line">            reqCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getNowTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这个算法虽然简单，但是有一个十分致命的问题， 那就是临界问题。</p>
<blockquote>
<p>如图所示</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/08/IwsqTQH1Dxoump7.jpg" alt="270324-20180926164026888-2038067154.jpg"></p>
<p>​    从上图可以看到， 假设在0:59时，瞬间发送了100个请求，并且在1:00又瞬间发送了100个请求，那么用户在一秒内瞬间发送了200个请求，按我们之前的规定是1分钟最多100个请求，平均到一秒就是1.7个请求，但是用户通过在时间窗口的重置节点处突发请求，可以瞬间超过我们的速率请求。用户有可能通过算法的这个漏洞，瞬间压垮我们的应用。</p>
<p>​    为什么出现这种情况，其实主要还是统计的精度太低导致，那有没有办法处理这种瞬间的请求呢？ 或者说，如何将临界问题的影响降低呢？答案是可以处理的。下面我们就来看一下滑动窗口算法。</p>
<h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><p>滑动窗口（<em>rolling window</em>), 可以很好的解决计算器算法的弊端（<em>临界问题</em>)。</p>
<blockquote>
<p>如图所示</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/08/AIFs67BQWdT1yih.jpg" alt="270324-20180926164034427-1114283823.jpg"></p>
<p>​    在上图中，一个红色的矩形框表示一个时间窗口， 在上述的例子中， 一个时间窗口就是一分钟。然后我们将时间窗口进行划分，比如图中将滑动窗口划分成6格，所以每格代表的是10秒钟，每过10秒，时间窗口往右滑动一格。而每个格子都有自己独立的计数器（<em>counter</em>)， 比如当一个请求在0:35秒的时候到达，那么0:30~0:39的格子对应的counter就会加一。</p>
<p>​    那滑动窗口怎么解决上面的临界问题的呢？ 我们可以看上图，0:59到达的100个请求落在灰色的格子中，而1:00到达的请求会落在橘黄色的格子中，当时间达到1:00时，窗口会往右移动一格，那么此时时间窗口内的总请求数一共是200个，超过最大值（<em>100</em>），所以能够被检测出来从而触发限流。</p>
<p>​    其实比较一下这两种算法可以发现，计数器算法其实也是等同于滑动窗口算法，只是没有对时间窗口进行划分，可以认为只有一格。</p>
<p>​    由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计也就越精确。</p>
<h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>令牌桶算法（<em>leaky bucket</em>)，原理是系统会以一个恒定的速度桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可以取时。则拒绝服务，当桶满时，新添加的令牌被丢弃或拒绝。</p>
<blockquote>
<p>如图所示</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/08/8LfPWcFZoHnCiQO.png" alt="TokenBucket.png"></p>
<div align=center>令牌桶算法</div>

<p>​    在<strong>Google Guava</strong>中提供一个<strong>RateLimiter</strong>工具类，就是基于<strong>令牌桶算法</strong>实现平滑突发的限流策略，令牌桶的还出是可以方便的改变速度，一旦需要提高速率，则按需提高放入桶中的令牌速率，一般会定时（比如1000毫秒）往桶中增加一定数量的令牌，有些变种算法则可以实时的计算应该增加的令牌数量。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.battcn.limiting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 令牌桶算法</span></span><br><span class="line"><span class="comment">     * 每秒生成 2 個令牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RateLimiter limiter = RateLimiter.create(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rateLimiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认就是 1</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> acquire = limiter.acquire(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前时间 - "</span> + LocalDateTime.now() + <span class="string">" - "</span> + Thread.currentThread().getName() + <span class="string">" - 阻塞 - "</span> + acquire + <span class="string">" 通过..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDemo1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            service.execute(<span class="keyword">this</span>::rateLimiter);</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前时间 - 2020-03-08T15:10:25.091 - pool-1-thread-2 - 阻塞 - 0.0 通过...</span><br><span class="line">当前时间 - 2020-03-08T15:10:25.531 - pool-1-thread-5 - 阻塞 - 0.453466 通过...</span><br><span class="line">当前时间 - 2020-03-08T15:10:26.031 - pool-1-thread-3 - 阻塞 - 0.953454 通过...</span><br><span class="line">当前时间 - 2020-03-08T15:10:26.531 - pool-1-thread-4 - 阻塞 - 1.453354 通过...</span><br><span class="line">当前时间 - 2020-03-08T15:10:27.031 - pool-1-thread-1 - 阻塞 - 1.952553 通过...</span><br></pre></td></tr></table></figure>

<p>​    在示例代码中，每秒产生了2个令牌，意味着500毫秒会产生一个令牌。</p>
<p>​    <em>limiter.acquire(num)</em>表示消费了多少个令牌，当桶中有足够的令牌时，则直接返回0，否则阻塞，直到有足够的令牌数才返回，返回的值为阻塞的时间。</p>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>​    漏桶算法(token bucket)，其主要的目的是控制数据注入到网络的速率，平滑网络上的突发流量，数据可以以任意速度流入漏桶中。漏桶可以看做是一个带有常量服务时间的单服务器队列，如果漏桶为空，则不需要流出水滴，如果漏桶（包缓存）溢出，那么水滴会被溢出丢弃。</p>
<blockquote>
<p>如图所示</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/08/Qw7NeACgumBYnHh.png" alt="token bucket.png"></p>
<div align=center>漏桶算法</div>

<p>​    漏桶算法可以通过<strong>信号量</strong>（<em>Semaphore</em>）的方式实现，很好的达到削峰的目的。</p>
<p>​    <strong>Semaphore</strong>是JDK1.5提供用于限制获取某种资源的线程数量，拥有公平、非公平两种模。公平模式是顺序获取信号，遵循<strong>先进先出</strong>（<em>FIFO</em>）。而非公平模式则是凭本事抢资源，想先进先出？<strong>不存在的</strong>。默认是非公平模式。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.battcn.limiting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLimiterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数器限流算法（允许将任务放入到缓冲队列）</span></span><br><span class="line"><span class="comment">     * 信号量，用来达到削峰的目的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">semaphoreLimiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列中允许存活的任务个数不能超过 5 个</span></span><br><span class="line">        <span class="keyword">if</span> (semaphore.getQueueLength() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(LocalDateTime.now() + <span class="string">" - "</span> + Thread.currentThread().getName() + <span class="string">" - 拒絕..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(LocalDateTime.now() + <span class="string">" - "</span> + Thread.currentThread().getName() + <span class="string">" - 通过..."</span>);</span><br><span class="line">                <span class="comment">//处理核心逻辑</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSemaphore</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            service.execute(<span class="keyword">this</span>::semaphoreLimiter);</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    如示例代码，队列中的任务存活个数就如同是水桶最多能盛装的水量，当超过这个阈值就会丢弃任务…</p>
<blockquote>
<p>执行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-08T15:17:00.236 - pool-1-thread-3 - 通过...</span><br><span class="line">2020-03-08T15:17:00.237 - pool-1-thread-2 - 通过...</span><br><span class="line">2020-03-08T15:17:00.236 - pool-1-thread-10 - 拒絕...</span><br><span class="line">2020-03-08T15:17:00.237 - pool-1-thread-1 - 通过...</span><br><span class="line">2020-03-08T15:17:02.237 - pool-1-thread-4 - 通过...</span><br><span class="line">2020-03-08T15:17:02.237 - pool-1-thread-5 - 通过...</span><br><span class="line">2020-03-08T15:17:02.237 - pool-1-thread-6 - 通过...</span><br><span class="line">2020-03-08T15:17:04.238 - pool-1-thread-9 - 通过...</span><br><span class="line">2020-03-08T15:17:04.238 - pool-1-thread-7 - 通过...</span><br><span class="line">2020-03-08T15:17:04.238 - pool-1-thread-8 - 通过...</span><br></pre></td></tr></table></figure>

<p>​    一共10个线程同时请求，初始信号量为3，表示最多可以同时处理3个任务，超出进入缓存区排队等待，当缓存区满了则拒绝接受新的请求。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    本篇文章主要是介绍了几种限流的算法，以上的一些做法其实还是针对本地限流的方案，到了分布式的环境中就凉了，接下的章节中，我也介绍一些在实际项目中怎么来实现限流，以及在分布式中怎么来进行限流。</p>
]]></content>
      <categories>
        <category>限流那些事</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用el-table进行动态渲染</title>
    <url>/2020/03/07/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8el-table%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在日常工作中， 经常会碰到表头字段不确定的情况，表头显示的字段名称需要根据后端接口的返回来动态渲染，这时候我们应该怎么处理了，本文将跟大家分享一下，如何使用el-table来进行动态渲染！</p>
<hr>
<a id="more"></a>

<p>​    首先，我们来看一下想要实现的效果。</p>
<blockquote>
<p>如图所示</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/07/pw4glkN8CWQydr5.png" alt="微信截图_20200307170707.png"></p>
<div align="center"> 效果一 </div>

<p><img src="https://i.loli.net/2020/03/07/mEQJr3FBwGLUcb2.png" alt="微信截图_20200307170840.png"></p>
<div align="center"> 效果二 </div>

<p>​    如上两张图可以发现， 表头部分是不确定的， 表头字段是根据接口的返回值来显示，而且表头的上半部分是不确定的，如统计的日期， 但是下半部分又是确定，如（本期，同期，同比）。</p>
<h3 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h3><p>​    首先需要实现这种效果我们先是要用到<strong>el-table-column</strong>的嵌套使用。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column v-for&#x3D;&quot;(item,key1) in tablehead.labels&quot; align&#x3D;&quot;center&quot; :key&#x3D;&quot;key1&quot; :label&#x3D;&quot;item.name&quot;&gt;</span><br><span class="line">        &lt;el-table-column v-for&#x3D;&quot;(value,key) in item.children&quot; align&#x3D;&quot;center&quot; :prop&#x3D;&quot;value.prop&quot; :key&#x3D;&quot;key&quot; :formatter&#x3D;&quot;nullFormatter&quot;</span><br><span class="line">          :label-class-name&#x3D;&quot;value.prop&quot; :label&#x3D;&quot;value.name&quot; :id&#x3D;&quot;key&quot;&gt;</span><br><span class="line">        &lt;&#x2F;el-table-column&gt;</span><br><span class="line">&lt;&#x2F;el-table-column&gt;</span><br></pre></td></tr></table></figure>

<h3 id="后端接口"><a href="#后端接口" class="headerlink" title="后端接口"></a>后端接口</h3><blockquote>
<p>数据结构</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"labels"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"2020-03-09"</span>,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"本期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KCurrPeriod2"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KLastPeriod2"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同比"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KYoy2"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"2020-03-10"</span>,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"本期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KCurrPeriod3"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KLastPeriod3"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同比"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KYoy3"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"2020-03-11"</span>,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"本期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KCurrPeriod4"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KLastPeriod4"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同比"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KYoy4"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"2020-03-12"</span>,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"本期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KCurrPeriod5"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KLastPeriod5"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同比"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KYoy5"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"datas"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">             </span><br><span class="line">                <span class="attr">"KCurrPeriod4"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KCurrPeriod5"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KCurrPeriod2"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KCurrPeriod3"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KYoy3"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KYoy2"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KYoy5"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KYoy4"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KLastPeriod4"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KLastPeriod5"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KLastPeriod2"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KLastPeriod3"</span>: <span class="string">"-"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    对比数据结构可以发现， 后端接口返回的格式也必须要以特定的格式，<strong>labels</strong>部分用来生成对应的表头字段，<strong>datas</strong>部分对应的就是数据。</p>
<p><img src="https://i.loli.net/2020/03/07/UOm8ZGnrvhcAXk3.png" alt="微信截图_20200307173659.png"><br>    如上所标识的，<strong>labels</strong>中的<strong>prop</strong>值需要跟<strong>datas</strong>中的<strong>key</strong>保持一致， 这样就可以进行动态渲染了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    动态渲染可能在日常工作中还是比较常见的需求，通过上述代码，对于前端来说实现起来动态渲染还是比较简单的， 其实主要还是后端接口格式要好好设计，所以其实这个艰巨的任务要交给后端的小伙伴了（嘻嘻，后端的小伙伴不要打哦！）。</p>
]]></content>
      <categories>
        <category>前端那些事</category>
      </categories>
      <tags>
        <tag>element-ui</tag>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
