<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>what is 限流？</title>
    <url>/2020/03/08/%E9%99%90%E6%B5%81%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E7%AF%87%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流。那么何为限流呢？通俗的解释：限流就是限制流量，这就好比移动每个月送你1G的流量， 用完就就没有了！通过限流，我们可以很好的控制系统的QPS，从而达到保护系统的目的，本篇作为限流那些事开篇， 将会介绍一些常用的限流算法以及各自的特点。</p>
<a id="more"></a>

<h3 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h3><p>​    计数器算法可以算是限流算法里最简单也是最容易实现的一种算法。举个栗子：比如现在有个需求是A接口一分钟的访问次数不能超过100次，那么可以怎么做呢？</p>
<p>​    首先，可以设置一个计数器（<strong>counter</strong>), 每当一个请求过来的时候counter + 1, 然后判断counter的值是否大于100并且该次请求与第一个请求的间隔时间是否在一分钟之内， 如果满足条件，说明请求过多，那么系统就需要给出提交， 例：（网络出现拥堵，请稍微再试）。假如该请求与第一个请求的间隔时间大于1分钟且counter的值还在限流范围内（&lt;100)，那么就需要重置counter，具体算法的示意图如下：</p>
<p><img src="https://i.loli.net/2020/03/08/sEQTgkmw5A9qWoG.jpg" alt="270324-20180926164018551-167363864.jpg"></p>
<p>​    具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> timeStamp = getNowTime();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> reqCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> limit = <span class="number">100</span>; <span class="comment">// 时间窗口内最大请求数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> interval = <span class="number">1000</span>; <span class="comment">// 时间窗口ms</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">grant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = getNowTime();</span><br><span class="line">        <span class="keyword">if</span> (now &lt; timeStamp + interval) &#123;</span><br><span class="line">            <span class="comment">// 在时间窗口内</span></span><br><span class="line">            reqCount++;</span><br><span class="line">            <span class="comment">// 判断当前时间窗口内是否超过最大请求控制数</span></span><br><span class="line">            <span class="keyword">return</span> reqCount &lt;= limit;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeStamp = now;</span><br><span class="line">            <span class="comment">// 超时后重置</span></span><br><span class="line">            reqCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getNowTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这个算法虽然简单，但是有一个十分致命的问题， 那就是临界问题。</p>
<blockquote>
<p>如图所示</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/08/IwsqTQH1Dxoump7.jpg" alt="270324-20180926164026888-2038067154.jpg"></p>
<p>​    从上图可以看到， 假设在0:59时，瞬间发送了100个请求，并且在1:00又瞬间发送了100个请求，那么用户在一秒内瞬间发送了200个请求，按我们之前的规定是1分钟最多100个请求，平均到一秒就是1.7个请求，但是用户通过在时间窗口的重置节点处突发请求，可以瞬间超过我们的速率请求。用户有可能通过算法的这个漏洞，瞬间压垮我们的应用。</p>
<p>​    为什么出现这种情况，其实主要还是统计的精度太低导致，那有没有办法处理这种瞬间的请求呢？ 或者说，如何将临界问题的影响降低呢？答案是可以处理的。下面我们就来看一下滑动窗口算法。</p>
<h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><p>滑动窗口（<em>rolling window</em>), 可以很好的解决计算器算法的弊端（<em>临界问题</em>)。</p>
<blockquote>
<p>如图所示</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/08/AIFs67BQWdT1yih.jpg" alt="270324-20180926164034427-1114283823.jpg"></p>
<p>​    在上图中，一个红色的矩形框表示一个时间窗口， 在上述的例子中， 一个时间窗口就是一分钟。然后我们将时间窗口进行划分，比如图中将滑动窗口划分成6格，所以每格代表的是10秒钟，每过10秒，时间窗口往右滑动一格。而每个格子都有自己独立的计数器（<em>counter</em>)， 比如当一个请求在0:35秒的时候到达，那么0:30~0:39的格子对应的counter就会加一。</p>
<p>​    那滑动窗口怎么解决上面的临界问题的呢？ 我们可以看上图，0:59到达的100个请求落在灰色的格子中，而1:00到达的请求会落在橘黄色的格子中，当时间达到1:00时，窗口会往右移动一格，那么此时时间窗口内的总请求数一共是200个，超过最大值（<em>100</em>），所以能够被检测出来从而触发限流。</p>
<p>​    其实比较一下这两种算法可以发现，计数器算法其实也是等同于滑动窗口算法，只是没有对时间窗口进行划分，可以认为只有一格。</p>
<p>​    由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计也就越精确。</p>
<h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>令牌桶算法（<em>leaky bucket</em>)，原理是系统会以一个恒定的速度桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可以取时。则拒绝服务，当桶满时，新添加的令牌被丢弃或拒绝。</p>
<blockquote>
<p>如图所示</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/08/8LfPWcFZoHnCiQO.png" alt="TokenBucket.png"></p>
<div align=center>令牌桶算法</div>

<p>​    在<strong>Google Guava</strong>中提供一个<strong>RateLimiter</strong>工具类，就是基于<strong>令牌桶算法</strong>实现平滑突发的限流策略，令牌桶的还出是可以方便的改变速度，一旦需要提高速率，则按需提高放入桶中的令牌速率，一般会定时（比如1000毫秒）往桶中增加一定数量的令牌，有些变种算法则可以实时的计算应该增加的令牌数量。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.battcn.limiting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 令牌桶算法</span></span><br><span class="line"><span class="comment">     * 每秒生成 2 個令牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RateLimiter limiter = RateLimiter.create(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rateLimiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认就是 1</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> acquire = limiter.acquire(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前时间 - "</span> + LocalDateTime.now() + <span class="string">" - "</span> + Thread.currentThread().getName() + <span class="string">" - 阻塞 - "</span> + acquire + <span class="string">" 通过..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDemo1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            service.execute(<span class="keyword">this</span>::rateLimiter);</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前时间 - 2020-03-08T15:10:25.091 - pool-1-thread-2 - 阻塞 - 0.0 通过...</span><br><span class="line">当前时间 - 2020-03-08T15:10:25.531 - pool-1-thread-5 - 阻塞 - 0.453466 通过...</span><br><span class="line">当前时间 - 2020-03-08T15:10:26.031 - pool-1-thread-3 - 阻塞 - 0.953454 通过...</span><br><span class="line">当前时间 - 2020-03-08T15:10:26.531 - pool-1-thread-4 - 阻塞 - 1.453354 通过...</span><br><span class="line">当前时间 - 2020-03-08T15:10:27.031 - pool-1-thread-1 - 阻塞 - 1.952553 通过...</span><br></pre></td></tr></table></figure>

<p>​    在示例代码中，每秒产生了2个令牌，意味着500毫秒会产生一个令牌。</p>
<p>​    <em>limiter.acquire(num)</em>表示消费了多少个令牌，当桶中有足够的令牌时，则直接返回0，否则阻塞，直到有足够的令牌数才返回，返回的值为阻塞的时间。</p>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>​    漏桶算法(token bucket)，其主要的目的是控制数据注入到网络的速率，平滑网络上的突发流量，数据可以以任意速度流入漏桶中。漏桶可以看做是一个带有常量服务时间的单服务器队列，如果漏桶为空，则不需要流出水滴，如果漏桶（包缓存）溢出，那么水滴会被溢出丢弃。</p>
<blockquote>
<p>如图所示</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/08/Qw7NeACgumBYnHh.png" alt="token bucket.png"></p>
<div align=center>漏桶算法</div>

<p>​    漏桶算法可以通过<strong>信号量</strong>（<em>Semaphore</em>）的方式实现，很好的达到削峰的目的。</p>
<p>​    <strong>Semaphore</strong>是JDK1.5提供用于限制获取某种资源的线程数量，拥有公平、非公平两种模。公平模式是顺序获取信号，遵循<strong>先进先出</strong>（<em>FIFO</em>）。而非公平模式则是凭本事抢资源，想先进先出？<strong>不存在的</strong>。默认是非公平模式。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.battcn.limiting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLimiterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数器限流算法（允许将任务放入到缓冲队列）</span></span><br><span class="line"><span class="comment">     * 信号量，用来达到削峰的目的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">semaphoreLimiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列中允许存活的任务个数不能超过 5 个</span></span><br><span class="line">        <span class="keyword">if</span> (semaphore.getQueueLength() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(LocalDateTime.now() + <span class="string">" - "</span> + Thread.currentThread().getName() + <span class="string">" - 拒絕..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(LocalDateTime.now() + <span class="string">" - "</span> + Thread.currentThread().getName() + <span class="string">" - 通过..."</span>);</span><br><span class="line">                <span class="comment">//处理核心逻辑</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSemaphore</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            service.execute(<span class="keyword">this</span>::semaphoreLimiter);</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    如示例代码，队列中的任务存活个数就如同是水桶最多能盛装的水量，当超过这个阈值就会丢弃任务…</p>
<blockquote>
<p>执行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-08T15:17:00.236 - pool-1-thread-3 - 通过...</span><br><span class="line">2020-03-08T15:17:00.237 - pool-1-thread-2 - 通过...</span><br><span class="line">2020-03-08T15:17:00.236 - pool-1-thread-10 - 拒絕...</span><br><span class="line">2020-03-08T15:17:00.237 - pool-1-thread-1 - 通过...</span><br><span class="line">2020-03-08T15:17:02.237 - pool-1-thread-4 - 通过...</span><br><span class="line">2020-03-08T15:17:02.237 - pool-1-thread-5 - 通过...</span><br><span class="line">2020-03-08T15:17:02.237 - pool-1-thread-6 - 通过...</span><br><span class="line">2020-03-08T15:17:04.238 - pool-1-thread-9 - 通过...</span><br><span class="line">2020-03-08T15:17:04.238 - pool-1-thread-7 - 通过...</span><br><span class="line">2020-03-08T15:17:04.238 - pool-1-thread-8 - 通过...</span><br></pre></td></tr></table></figure>

<p>​    一共10个线程同时请求，初始信号量为3，表示最多可以同时处理3个任务，超出进入缓存区排队等待，当缓存区满了则拒绝接受新的请求。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    本篇文章主要是介绍了几种限流的算法，以上的一些做法其实还是针对本地限流的方案，到了分布式的环境中就凉了，接下的章节中，我也介绍一些在实际项目中怎么来实现限流，以及在分布式中怎么来进行限流。</p>
]]></content>
      <categories>
        <category>限流那些事</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用el-table进行动态渲染</title>
    <url>/2020/03/07/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8el-table%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在日常工作中， 经常会碰到表头字段不确定的情况，表头显示的字段名称需要根据后端接口的返回来动态渲染，这时候我们应该怎么处理了，本文将跟大家分享一下，如何使用el-table来进行动态渲染！</p>
<hr>
<a id="more"></a>

<p>​    首先，我们来看一下想要实现的效果。</p>
<blockquote>
<p>如图所示</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/07/pw4glkN8CWQydr5.png" alt="微信截图_20200307170707.png"></p>
<div align="center"> 效果一 </div>

<p><img src="https://i.loli.net/2020/03/07/mEQJr3FBwGLUcb2.png" alt="微信截图_20200307170840.png"></p>
<div align="center"> 效果二 </div>

<p>​    如上两张图可以发现， 表头部分是不确定的， 表头字段是根据接口的返回值来显示，而且表头的上半部分是不确定的，如统计的日期， 但是下半部分又是确定，如（本期，同期，同比）。</p>
<h3 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h3><p>​    首先需要实现这种效果我们先是要用到<strong>el-table-column</strong>的嵌套使用。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column v-for&#x3D;&quot;(item,key1) in tablehead.labels&quot; align&#x3D;&quot;center&quot; :key&#x3D;&quot;key1&quot; :label&#x3D;&quot;item.name&quot;&gt;</span><br><span class="line">        &lt;el-table-column v-for&#x3D;&quot;(value,key) in item.children&quot; align&#x3D;&quot;center&quot; :prop&#x3D;&quot;value.prop&quot; :key&#x3D;&quot;key&quot; :formatter&#x3D;&quot;nullFormatter&quot;</span><br><span class="line">          :label-class-name&#x3D;&quot;value.prop&quot; :label&#x3D;&quot;value.name&quot; :id&#x3D;&quot;key&quot;&gt;</span><br><span class="line">        &lt;&#x2F;el-table-column&gt;</span><br><span class="line">&lt;&#x2F;el-table-column&gt;</span><br></pre></td></tr></table></figure>

<h3 id="后端接口"><a href="#后端接口" class="headerlink" title="后端接口"></a>后端接口</h3><blockquote>
<p>数据结构</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"labels"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"2020-03-09"</span>,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"本期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KCurrPeriod2"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KLastPeriod2"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同比"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KYoy2"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"2020-03-10"</span>,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"本期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KCurrPeriod3"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KLastPeriod3"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同比"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KYoy3"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"2020-03-11"</span>,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"本期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KCurrPeriod4"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KLastPeriod4"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同比"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KYoy4"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"2020-03-12"</span>,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"本期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KCurrPeriod5"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KLastPeriod5"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同比"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KYoy5"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"datas"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">             </span><br><span class="line">                <span class="attr">"KCurrPeriod4"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KCurrPeriod5"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KCurrPeriod2"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KCurrPeriod3"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KYoy3"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KYoy2"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KYoy5"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KYoy4"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KLastPeriod4"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KLastPeriod5"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KLastPeriod2"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KLastPeriod3"</span>: <span class="string">"-"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    对比数据结构可以发现， 后端接口返回的格式也必须要以特定的格式，<strong>labels</strong>部分用来生成对应的表头字段，<strong>datas</strong>部分对应的就是数据。</p>
<p><img src="https://i.loli.net/2020/03/07/UOm8ZGnrvhcAXk3.png" alt="微信截图_20200307173659.png"><br>    如上所标识的，<strong>labels</strong>中的<strong>prop</strong>值需要跟<strong>datas</strong>中的<strong>key</strong>保持一致， 这样就可以进行动态渲染了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    动态渲染可能在日常工作中还是比较常见的需求，通过上述代码，对于前端来说实现起来动态渲染还是比较简单的， 其实主要还是后端接口格式要好好设计，所以其实这个艰巨的任务要交给后端的小伙伴了（嘻嘻，后端的小伙伴不要打哦！）。</p>
]]></content>
      <categories>
        <category>前端那些事</category>
      </categories>
      <tags>
        <tag>element-ui</tag>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
