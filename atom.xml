<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChihW&#39;s Blog</title>
  
  <subtitle>专注前端30年</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.chihw.cn/"/>
  <updated>2020-03-12T15:19:13.658Z</updated>
  <id>https://blog.chihw.cn/</id>
  
  <author>
    <name>ChihW</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>限流那些事（三） -- 如何在Spring Boot中使用Sentinel框架</title>
    <link href="https://blog.chihw.cn/2020/03/11/%E9%99%90%E6%B5%81%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%89%EF%BC%89----%E5%A6%82%E4%BD%95%E5%9C%A8Spring-Boot%E4%B8%AD%E6%98%AFSentinel%E6%A1%86%E6%9E%B6/"/>
    <id>https://blog.chihw.cn/2020/03/11/%E9%99%90%E6%B5%81%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%89%EF%BC%89----%E5%A6%82%E4%BD%95%E5%9C%A8Spring-Boot%E4%B8%AD%E6%98%AFSentinel%E6%A1%86%E6%9E%B6/</id>
    <published>2020-03-11T01:14:15.853Z</published>
    <updated>2020-03-12T15:19:13.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    上篇中给大家介绍了如何在Spring Boot项目中使用Google Guava提供的RateLimiter类（令牌桶算法实现），并使用自定义注解的方式进行限流操作， 基本上可以满足一些简单的限流需求，但是也有局限性（如不适用分布式环境， 通用性不佳），所以本篇将介绍阿里中间件团队开源的限流框架（<em>Sentinel</em>），并将结合Spring Boot的项目，来看一下他们两者结合会产生什么效果吧！</p><hr><a id="more"></a><h3 id="Sentinel介绍"><a href="#Sentinel介绍" class="headerlink" title="Sentinel介绍"></a>Sentinel介绍</h3><p>​    首先简单介绍一下Sentinel（<em>分布式系统的流量防卫兵</em>）框架，它是阿里开源的一套流控框架（阿里，你懂得！<strong>阿里出品，必属精品~</strong>） ，Sentinel以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来保护系统的稳定性。Sentinel框架跟Netflix Hystrix框架的作用类似， 只是Hystrix现在已经不维护了。</p><blockquote><p>主要特性</p></blockquote><p><img src="https://i.loli.net/2020/03/11/Pq9M5akCYOpQthr.png" alt="50505538-2c484880-0aaf-11e9-9ffc-cbaaef20be2b.png"></p><p>​    Sentinel主要分为两部分：</p><ul><li><p>核心库，提供了流量控制、熔断降级、负载保护等很多功能。同时对Dubbo/Spring Cloud都有很好的支持。</p></li><li><p>控制台（Dashboard），基于Spring Boot开发，可以查看实时流控情况。</p></li></ul><blockquote><p>对比Hystrix</p></blockquote><table><thead><tr><th align="center">对比内容</th><th align="center">Sentinel</th><th align="center">Hystrix</th></tr></thead><tbody><tr><td align="center">隔离策略</td><td align="center">基于并发数</td><td align="center">线程池隔离/信号量隔离</td></tr><tr><td align="center">熔断降级策略</td><td align="center">基于响应时间或失败比率</td><td align="center">基于失败比率</td></tr><tr><td align="center">实时指标实现</td><td align="center">滑动窗口</td><td align="center">滑动窗口（基于 RxJava）</td></tr><tr><td align="center">规则配置</td><td align="center">支持多种数据源</td><td align="center">支持多种数据源</td></tr><tr><td align="center">扩展性</td><td align="center">多个扩展点</td><td align="center">插件的形式</td></tr><tr><td align="center">基于注解的支持</td><td align="center">即将发布</td><td align="center">支持</td></tr><tr><td align="center">调用链路信息</td><td align="center">支持同步调用</td><td align="center">不支持</td></tr><tr><td align="center">限流</td><td align="center">基于 QPS / 并发数，支持基于调用关系的限流</td><td align="center">不支持</td></tr><tr><td align="center">流量整形</td><td align="center">支持慢启动、匀速器模式</td><td align="center">不支持</td></tr><tr><td align="center">系统负载保护</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">实时监控 API</td><td align="center">各式各样</td><td align="center">较为简单</td></tr><tr><td align="center">控制台</td><td align="center">开箱即用，可配置规则、查看秒级监控、机器发现等</td><td align="center">不完善</td></tr><tr><td align="center">常见框架的适配</td><td align="center">Servlet、Spring Cloud、Dubbo、gRPC 等</td><td align="center">Servlet、Spring Cloud Netflix</td></tr></tbody></table><p>​    从对比的表格可以看出， Sentinel比Hystrix在功能上还是要强一些， 而且Sentinel也成为了Spring Cloud官方的主流推荐之一。</p><h3 id="Sentinel实战"><a href="#Sentinel实战" class="headerlink" title="Sentinel实战"></a>Sentinel实战</h3><p>​    Sentinel可以通过控制台的方式来管理流控规则，也可以查看实时监控，机器列表等信息。</p><h4 id="部署控制台"><a href="#部署控制台" class="headerlink" title="部署控制台"></a>部署控制台</h4><p>​    从<a href="https://github.com/alibaba/Sentinel/releases" target="_blank" rel="noopener">release页面</a>上获取最新版本的控制台Jar包（<em>1.7.1</em>），也可以下载源码进行构建。</p><blockquote><p>注意：JDK版本需1.8及以上</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=<span class="number">8080</span> -Dcsp.sentinel.dashboard.server=localhost:<span class="number">8080</span> -Dproject.name=sentinel-dashboard -jar sentinel-dashboard<span class="number">.1</span><span class="number">.7</span><span class="number">.1</span>.jar</span><br></pre></td></tr></table></figure><p>​    其中-Dserver.port=8080用于指定Sentinel控制台端口。</p><blockquote><p>启动成功</p></blockquote><p><img src="https://i.loli.net/2020/03/11/QHvRKgBdyJYaTNV.png" alt="微信截图_20200311210138.png"></p><p>​    默认用户/密码： sentinel/sentinel。</p><h4 id="接入控制台"><a href="#接入控制台" class="headerlink" title="接入控制台"></a>接入控制台</h4><ul><li><pre><code class="yaml"><span class="string">compile("com.alibaba.cloud:spring-cloud-starter-alibaba-sentinel:1.5.0.RELEASE")</span></code></pre><p>项目使用的是gradle构建， maven项目加入<dependency>。</p></li></ul><blockquote><p>注意事项：sentinel版本需要根据Spring Boot 的版本来， 项目使用的是Spring Boot 1.0, 所以Sentinel也引入1.0的版本。如使用Spring Boot 2.0，那相应的Sentinel也需要使用2.0</p></blockquote><h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h4><p>​    启动时加入JVM参数 <code>-Dcsp.sentinel.dashboard.server=consoleIp:port</code> 指定控制台地址和端口，Spring Boot项目可以直接在application.yml中配置</p><blockquote><p>接入配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">minions</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8089</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line">      <span class="attr">eager:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>​    application.name指定接入客户端的名字（建议填写），sentinel.transport.port指定本地启动的服务对应的端口号， 默认是8719，可以不指定， Sentinel会自动查找。sentinel.transport.dashboard指定客户端地址。根据前面启动的控制台来配置就行了。sentinel.eager关闭懒加载（<em>由于Sentinel采用的是懒加载模式，即客户端需要发起一次请求， Sentinel才会记录下来， 如果想要启动的时候就让Sentinel服务进行请求的拦截， 将eager设置为true即可</em>）。</p><blockquote><p>接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shcepp.miniapp.business.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.shcepp.miniapp.business.service.IPreClassifyService;</span><br><span class="line"><span class="keyword">import</span> com.shcepp.miniapp.sys.util.ApiResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"Test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IPreClassifyService preClassifyService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有注解通过自适应的限流（资源名使用的是URL)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/limit"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiResult <span class="title">testLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult(<span class="string">"T"</span>, <span class="string">"200"</span>, <span class="string">"成功"</span>, <span class="string">"OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过注解方式指定限流资源名（Sentinel官方推荐放到Service层）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/limitWithAnno/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiResult <span class="title">testLimitWithAnno</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 资源名是sayHello</span></span><br><span class="line">        String result = preClassifyService.sayHello(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult(<span class="string">"T"</span>, <span class="string">"200"</span>, <span class="string">"成功"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    新建一个普通的RestController即可。</p><h4 id="查看接入情况"><a href="#查看接入情况" class="headerlink" title="查看接入情况"></a>查看接入情况</h4><blockquote><p>如图所示</p></blockquote><p><img src="https://i.loli.net/2020/03/11/f7Gadx4WrHg5ZuO.png" alt="微信截图_20200311211805.png"></p><p>​    登录Sentinel，如果控制台出现配置的application.name, 说明接入成功， 如果没有接入成功， 可以进入${user.home}/logs/csp/sentinel-record.log.xxx日志来排查原因。</p><blockquote><p>Tips：圆圈中的数字表示目前客户端的健康状况， 接入的客户端会定时向客户端发送心跳包， 如果客户端断开， 那么圆圈里面的数量会小于后面的数字。</p></blockquote><h4 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h4><p>​    成功接入Sentinel控制台之后， 就可以在控制台中设置流控规则了。</p><blockquote><p>如图所示</p></blockquote><p><img src="https://i.loli.net/2020/03/11/H7m5MIAoqTdUuVw.png" alt="微信截图_20200311212415.png"></p><p>​    查看簇点链路， 查看所有被Sentinel服务记录的资源。在接口的后面可以进行规则设置。</p><blockquote><p>如图所示</p></blockquote><p><img src="https://i.loli.net/2020/03/11/cTahe8QJZIvFtMA.png" alt="微信截图_20200311212935.png"></p><p>​    下面我们将对流控规则做一个详细的了解， 以便更好的进行限流的操作。</p><ul><li><p>资源名</p><p>配置规则的资源名， 只要接入到控制台的资源， Sentinel都会自动记录， 不可更改。一般使用编程的时候会用来设置。</p></li><li><p>针对来源</p><p>三种情况可选</p><blockquote><p>default</p></blockquote><p>表示不区分调用者，来自任何调用者的请求都将进行限流统计。</p><blockquote><p>{origin_name}</p></blockquote><p>表示特定的调用者，只有来自这个调用者的请求才会进行流量控制</p><blockquote><p>other</p></blockquote><p>表示除{oragin_name}以外的其余调用方的请求进行流量控制。</p></li><li><p>阈值类型</p><p>可以针对QPS或者线程数。</p></li><li><p>单机阈值</p><p>单机模式下针对阈值类型设置的值。如果集群模式可以设置整体阈值</p></li><li><p>是否集群</p><p>Sentinel部署了多台机器， 可以开启集群模式。</p></li><li><p>流控模式</p><p>三种情况可选</p><blockquote><p>直接</p></blockquote><p>根据调用方进行限流， 跟前面的来源结合可以在不同的场景中进行流量控制。</p><blockquote><p>关联</p></blockquote><p>当两个资源之间具有争抢或者依赖关系是，那么这两个资源便具有关联，可以使用关联限流来避免出现过度的争抢。</p><p>举例说明：比如对同一个东西read和write的两个资源进行关联限流， 当write操作过于频繁时，读的请求会被限流， 反之亦然。</p><blockquote><p>链路</p></blockquote><p>根据调用链路入口限流。</p><p>举例说明：来自两个入口Entrance1和Entrance2的请求都调用了同一个资源， Sentinel可以根据某个入口的统计信息来对资源进行限流，比如说针对Entrance1的请求限流， Entrance2的请求可以放行。</p></li><li><p>流控效果</p><p>三种策略可选</p><blockquote><p>快速失败</p></blockquote><p>当QPS或者线程数超过规则的阈值后， 新的请求就会被立即拒绝， 拒绝方式为抛出FlowException。</p><p>这种方式适用于对系统处理能力已知的情况。</p><blockquote><p>Warm Up</p></blockquote><p>慢启动又称为“匀速器模式”，这种方式严格控制了请求通过的间隔时间，也就是让请求以均匀的速度通过， 对应的是漏桶算法。主要用于处理间隔性突发的流量，如一段时间内流量特别大， 但是接下来的时间内， 系统有比较空闲的情况。</p><blockquote><p>排队等待</p></blockquote><p>排队等待又称为“冷启动”。主要用于当系统长期处于低水位的情况下，流量突然增加时， 直接把系统升到高水位可能瞬间把系统压垮，通过冷启动，可以让流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间。</p></li></ul><h4 id="流控验证"><a href="#流控验证" class="headerlink" title="流控验证"></a>流控验证</h4><blockquote><p>正常访问</p></blockquote><p><img src="https://i.loli.net/2020/03/11/2rU3vuhFtXyVQR8.png" alt="微信截图_20200311213155.png"></p><blockquote><p>被拦截访问</p></blockquote><p><img src="https://i.loli.net/2020/03/11/YeVFyhkN5dqtCTl.png" alt="微信截图_20200311213333.png"></p><p>​    可以看到刚才的流控规则生效了。</p><h4 id="规则持久化"><a href="#规则持久化" class="headerlink" title="规则持久化"></a>规则持久化</h4><p>​    服务重启后，规则怎么不见了， 什么鬼（<strong>黑人问号？？？？</strong>）。不要奇怪，因为Sentinel默认情况下规则是保存在内存中的， 重启后当然会不见了。这时候大家就会有疑问，那如果想要在线上环境使用Sentinel怎么办呢？有二种选择</p><ul><li>用阿里云上的付费版本（土豪的选择）</li><li>实现规则的持久化</li></ul><p>像我们这种穷人，花钱是不可能， 一分钱都不可能花的。那么就来自己实现规则的持久化吧！    </p><blockquote><p>如图所示</p></blockquote><p><img src="https://i.loli.net/2020/03/11/usq6L2W7kh9pDGN.png" alt="5417792-0669ef18170d1989.png"></p><p>​    如上图所示， 当Sentinel的客户端挂掉之后， 保存在各个RuleManager中的规则都会灰飞烟灭。</p><p>​    其实我们要做的很简单， 就是将原本保存在RuleManager内存中的规则， 持久化一份副本出去，这样客户端重启之后， 可以直接将持久化的副本在load到内存中。</p><p>​    目前Sentinel实现了5中规则持久化的方式。</p><ul><li>file<ul><li><a href="https://www.imooc.com/article/289402" target="_blank" rel="noopener">传送门</a></li></ul></li><li>redis<ul><li><a href="https://blog.csdn.net/qq_42714869/article/details/94553378" target="_blank" rel="noopener">传送门</a></li></ul></li><li>nacos<ul><li><a href="https://blog.csdn.net/lilizhou2008/article/details/97075236" target="_blank" rel="noopener">传送门</a></li></ul></li><li>zk<ul><li><a href="https://blog.csdn.net/rodbate/article/details/89763669" target="_blank" rel="noopener">传送门</a></li></ul></li><li>apollo<ul><li><a href="https://www.cnblogs.com/kiwifly/p/11569190.html" target="_blank" rel="noopener">传送门</a></li></ul></li></ul><p>具体的实现就不介绍了， 收集了一些大神写的教程， 大伙儿按需来吧！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    本章主要给大家简单介绍如何在Spring Boot项目中使用Sentinel来进行流控， 我们看到Sentinel确实是一个很优秀的流控框架，不仅可以进行限流配置， 还可以配置降级， 热点参数等很多功能。基本上可以用来代替原来的Hystrix框架了， 而且还提供了Dashboard， 让配置规则更加简单， 但是比较坑的是， 规则无法持久化， 需要自己实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    上篇中给大家介绍了如何在Spring Boot项目中使用Google Guava提供的RateLimiter类（令牌桶算法实现），并使用自定义注解的方式进行限流操作， 基本上可以满足一些简单的限流需求，但是也有局限性（如不适用分布式环境， 通用性不佳），所以本篇将介绍阿里中间件团队开源的限流框架（&lt;em&gt;Sentinel&lt;/em&gt;），并将结合Spring Boot的项目，来看一下他们两者结合会产生什么效果吧！&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="限流那些事" scheme="https://blog.chihw.cn/categories/%E9%99%90%E6%B5%81%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    
    
      <category term="Spring Boot" scheme="https://blog.chihw.cn/tags/Spring-Boot/"/>
    
      <category term="Sentinel" scheme="https://blog.chihw.cn/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>限流那些事（二） -- 如何在Spring Boot项目中使用限流</title>
    <link href="https://blog.chihw.cn/2020/03/10/%E9%99%90%E6%B5%81%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%BA%8C%EF%BC%89----%E5%A6%82%E4%BD%95%E5%9C%A8spring-boot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%99%90%E6%B5%81/"/>
    <id>https://blog.chihw.cn/2020/03/10/%E9%99%90%E6%B5%81%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%BA%8C%EF%BC%89----%E5%A6%82%E4%BD%95%E5%9C%A8spring-boot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%99%90%E6%B5%81/</id>
    <published>2020-03-10T01:16:09.362Z</published>
    <updated>2020-03-12T15:17:29.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在上一篇中， 介绍了限流的一些基本概念以及常见的限流算法， 俗话说：能动手就别哔哔！（(#^.^#)本章将结合实际的项目（<strong>Spring Boot</strong>)来使用限流策略，并且使用注解的方式来进行灵活配置， 本篇做为限流那些事篇二，主要介绍限流在实际项目中的使用。</p><a id="more"></a><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>​    利用<strong>自定义注解</strong>、<strong>Spring Aop</strong>实现应用级灵活配置的限流…</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>​    新建Spring Boot 工程， 这个很简单， 通过IDEA进行傻瓜式创建…</p><h4 id="导入依赖包"><a href="#导入依赖包" class="headerlink" title="导入依赖包"></a>导入依赖包</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// guava</span></span><br><span class="line">compile(<span class="string">"com.google.guava:18.0"</span>)</span><br></pre></td></tr></table></figure><p>​    示例项目用的是gradle构建（<em>使用maven构建的话， 引入相应的依赖就行了</em>），这里主要使用的Google Guava提供的RateLimiter工具类。上篇介绍了Google Guava提供的RateLimiter类实现了令牌桶算法。这里说些题外话，本身Google的Guava包里面有非常多且好用的工具类， 下次有时间的话会跟大家一起分享一下Guava包中那些好用的工具类！</p><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><blockquote><p>示例代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shcepp.miniapp.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ChihW</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TbLimiter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每秒向桶中放入令牌的数量   默认最大即不做限流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">perSecond</span><span class="params">()</span> <span class="keyword">default</span> Double.MAX_VALUE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取令牌的等待时间  默认0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeOut</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TimeUnit <span class="title">timeOutUnit</span><span class="params">()</span> <span class="keyword">default</span> TimeUnit.MILLISECONDS</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无法获取令牌返回提示信息 默认值可以自行修改</span></span><br><span class="line">    <span class="function">String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "系统繁忙,请稍后再试."</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    自定义注解中定义了value（<em>令牌数</em>), preSecond(<em>每秒放入的令牌数量</em>)，timeOut(<em>令牌获取超时时间</em>),msg(<em>获取不到令牌返回的错误信息</em>)。注解后面会用到。</p><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><blockquote><p>示例代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shcepp.miniapp.business.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"><span class="keyword">import</span> com.shcepp.miniapp.annotation.TbLimiter;</span><br><span class="line"><span class="keyword">import</span> com.shcepp.miniapp.sys.util.ApiResult;</span><br><span class="line"><span class="keyword">import</span> com.shcepp.miniapp.sys.util.Constants;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.Signature;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by ChihW</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenBucketLimiterAspact</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private final Map&lt;String, RateLimiter&gt; rateLimiters = new ConcurrentHashMap&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RateLimiter rateLimiter = RateLimiter.create(Double.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.LimitSwitch:1&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String limitSwitch;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(@org.springframework.web.bind.annotation.RestController *) &amp;&amp;"</span> +</span><br><span class="line">            <span class="string">"@annotation(com.shcepp.miniapp.annotation.TbLimiter)"</span> +</span><br><span class="line">            <span class="string">"execution(* *(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">controller</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"controller()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">cusAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"拦截到了&#123;&#125;方法..."</span>, pjp.getSignature().getName());</span><br><span class="line">        <span class="comment">// 是否开启限流</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"1"</span>.equals(limitSwitch)) &#123;</span><br><span class="line">            Signature signature = pjp.getSignature();</span><br><span class="line">            MethodSignature methodSignature = (MethodSignature)signature;</span><br><span class="line">            <span class="comment">//获取目标方法</span></span><br><span class="line">            Method targetMethod = methodSignature.getMethod();</span><br><span class="line">            <span class="keyword">if</span> (targetMethod.isAnnotationPresent(TbLimiter<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="comment">//获取目标方法的@TbLimiter注解</span></span><br><span class="line">                TbLimiter lxRateLimit = targetMethod.getAnnotation(TbLimiter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                rateLimiter.setRate(lxRateLimit.perSecond());</span><br><span class="line">                <span class="keyword">if</span> (!rateLimiter.tryAcquire(lxRateLimit.timeOut(), lxRateLimit.timeOutUnit()))</span><br><span class="line">                    <span class="keyword">return</span> ApiResult.newInstance(Constants.CLIENT_FLAG.FLAG_F,</span><br><span class="line">                            Constants.CLIENT_ERROR_900.ERROR_CODE906,</span><br><span class="line">                            lxRateLimit.msg(),</span><br><span class="line">                            <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"controller()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ecsBefore</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//        logger.debug("testBefore");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"controller()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ecsAfter</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//        logger.debug("testAfter");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    使用切面来拦截所有使用了自定义限流注解的方法（<em>@TbLimiter</em>)。获取到注解上的参数进行限流判断，如果超过了限流的阈值， 则直接进行降级操作。</p><h4 id="方法限流"><a href="#方法限流" class="headerlink" title="方法限流"></a>方法限流</h4><blockquote><p>示例代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shcepp.miniapp.business.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"Test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/limit"</span>)</span><br><span class="line">    <span class="meta">@TbLimiter</span>(value = <span class="number">2</span>, perSecond = <span class="number">1.0</span>, timeOut = <span class="number">100</span>, msg = <span class="string">"亲,现在流量过大,请稍后再试."</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiResult <span class="title">testLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult(<span class="string">"T"</span>, <span class="string">"200"</span>, <span class="string">"成功"</span>, <span class="string">"OK!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在需要限流的方法上加上<strong>@TbLimiter</strong>注解，设置令牌桶的容量是2个， 每秒放入一个令牌，超时时间为100毫秒（<em>当然这是测试用， 正式使用还是需要根据实际情况进行调整</em>)，然后就可以测试一下限流是否有效果，可以使用postman或者使用jmeter工具测试。</p><blockquote><p>运行结果(正常执行)</p></blockquote><p><img src="https://i.loli.net/2020/03/10/SEa9BfU1knPCrGl.png" alt="tb_success.png"></p><p>​    未超过阈值，可以直接执行！</p><blockquote><p>运行结果(限流)</p></blockquote><p><img src="https://i.loli.net/2020/03/10/kpVZKYG65DO4XFl.png" alt="tb_error.png"></p><p>​    超过阈值，进行限流，正式使用时，可以配置降级方法， 统一管理限流之后的操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    总体来说，本章主要是结合实际项目（<strong>Spring Boot</strong>），来进行限流操作，当然目前介绍的还都是单机版的限流， 也就是在分布式的环境中是不能使用的， 但是可以满足一些比较简单的限流需求， 后面的章节中，我将给大家介绍分布式限流的实现方法，以及如何在接入层做限流。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    在上一篇中， 介绍了限流的一些基本概念以及常见的限流算法， 俗话说：能动手就别哔哔！（(#^.^#)本章将结合实际的项目（&lt;strong&gt;Spring Boot&lt;/strong&gt;)来使用限流策略，并且使用注解的方式来进行灵活配置， 本篇做为限流那些事篇二，主要介绍限流在实际项目中的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="限流那些事" scheme="https://blog.chihw.cn/categories/%E9%99%90%E6%B5%81%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    
    
      <category term="web" scheme="https://blog.chihw.cn/tags/web/"/>
    
      <category term="Spring Boot" scheme="https://blog.chihw.cn/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>限流那些事（一） -- what is 限流？</title>
    <link href="https://blog.chihw.cn/2020/03/08/%E9%99%90%E6%B5%81%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E7%AF%87%E4%B8%80%EF%BC%89/"/>
    <id>https://blog.chihw.cn/2020/03/08/%E9%99%90%E6%B5%81%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E7%AF%87%E4%B8%80%EF%BC%89/</id>
    <published>2020-03-08T09:10:33.394Z</published>
    <updated>2020-03-10T04:01:31.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流。那么何为限流呢？通俗的解释：限流就是限制流量，这就好比移动每个月送你1G的流量， 用完就就没有了！通过限流，我们可以很好的控制系统的QPS，从而达到保护系统的目的，本篇作为限流那些事开篇， 将会介绍一些常用的限流算法以及各自的特点。</p><a id="more"></a><h3 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h3><p>​    计数器算法可以算是限流算法里最简单也是最容易实现的一种算法。举个栗子：比如现在有个需求是A接口一分钟的访问次数不能超过100次，那么可以怎么做呢？</p><p>​    首先，可以设置一个计数器（<strong>counter</strong>), 每当一个请求过来的时候counter + 1, 然后判断counter的值是否大于100并且该次请求与第一个请求的间隔时间是否在一分钟之内， 如果满足条件，说明请求过多，那么系统就需要给出提交， 例：（网络出现拥堵，请稍微再试）。假如该请求与第一个请求的间隔时间大于1分钟且counter的值还在限流范围内（&lt;100)，那么就需要重置counter，具体算法的示意图如下：</p><p><img src="https://i.loli.net/2020/03/08/sEQTgkmw5A9qWoG.jpg" alt="270324-20180926164018551-167363864.jpg"></p><p>​    具体的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> timeStamp = getNowTime();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> reqCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> limit = <span class="number">100</span>; <span class="comment">// 时间窗口内最大请求数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> interval = <span class="number">1000</span>; <span class="comment">// 时间窗口ms</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">grant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = getNowTime();</span><br><span class="line">        <span class="keyword">if</span> (now &lt; timeStamp + interval) &#123;</span><br><span class="line">            <span class="comment">// 在时间窗口内</span></span><br><span class="line">            reqCount++;</span><br><span class="line">            <span class="comment">// 判断当前时间窗口内是否超过最大请求控制数</span></span><br><span class="line">            <span class="keyword">return</span> reqCount &lt;= limit;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeStamp = now;</span><br><span class="line">            <span class="comment">// 超时后重置</span></span><br><span class="line">            reqCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getNowTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这个算法虽然简单，但是有一个十分致命的问题， 那就是临界问题。</p><blockquote><p>如图所示</p></blockquote><p><img src="https://i.loli.net/2020/03/08/IwsqTQH1Dxoump7.jpg" alt="270324-20180926164026888-2038067154.jpg"></p><p>​    从上图可以看到， 假设在0:59时，瞬间发送了100个请求，并且在1:00又瞬间发送了100个请求，那么用户在一秒内瞬间发送了200个请求，按我们之前的规定是1分钟最多100个请求，平均到一秒就是1.7个请求，但是用户通过在时间窗口的重置节点处突发请求，可以瞬间超过我们的速率请求。用户有可能通过算法的这个漏洞，瞬间压垮我们的应用。</p><p>​    为什么出现这种情况，其实主要还是统计的精度太低导致，那有没有办法处理这种瞬间的请求呢？ 或者说，如何将临界问题的影响降低呢？答案是可以处理的。下面我们就来看一下滑动窗口算法。</p><h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><p>滑动窗口（<em>rolling window</em>), 可以很好的解决计算器算法的弊端（<em>临界问题</em>)。</p><blockquote><p>如图所示</p></blockquote><p><img src="https://i.loli.net/2020/03/08/AIFs67BQWdT1yih.jpg" alt="270324-20180926164034427-1114283823.jpg"></p><p>​    在上图中，一个红色的矩形框表示一个时间窗口， 在上述的例子中， 一个时间窗口就是一分钟。然后我们将时间窗口进行划分，比如图中将滑动窗口划分成6格，所以每格代表的是10秒钟，每过10秒，时间窗口往右滑动一格。而每个格子都有自己独立的计数器（<em>counter</em>)， 比如当一个请求在0:35秒的时候到达，那么0:30~0:39的格子对应的counter就会加一。</p><p>​    那滑动窗口怎么解决上面的临界问题的呢？ 我们可以看上图，0:59到达的100个请求落在灰色的格子中，而1:00到达的请求会落在橘黄色的格子中，当时间达到1:00时，窗口会往右移动一格，那么此时时间窗口内的总请求数一共是200个，超过最大值（<em>100</em>），所以能够被检测出来从而触发限流。</p><p>​    其实比较一下这两种算法可以发现，计数器算法其实也是等同于滑动窗口算法，只是没有对时间窗口进行划分，可以认为只有一格。</p><p>​    由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计也就越精确。</p><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>令牌桶算法（<em>leaky bucket</em>)，原理是系统会以一个恒定的速度桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可以取时。则拒绝服务，当桶满时，新添加的令牌被丢弃或拒绝。</p><blockquote><p>如图所示</p></blockquote><p><img src="https://i.loli.net/2020/03/08/8LfPWcFZoHnCiQO.png" alt="TokenBucket.png"></p><div align=center>令牌桶算法</div><p>​    在<strong>Google Guava</strong>中提供一个<strong>RateLimiter</strong>工具类，就是基于<strong>令牌桶算法</strong>实现平滑突发的限流策略，令牌桶的还出是可以方便的改变速度，一旦需要提高速率，则按需提高放入桶中的令牌速率，一般会定时（比如1000毫秒）往桶中增加一定数量的令牌，有些变种算法则可以实时的计算应该增加的令牌数量。</p><blockquote><p>示例代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.battcn.limiting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 令牌桶算法</span></span><br><span class="line"><span class="comment">     * 每秒生成 2 個令牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RateLimiter limiter = RateLimiter.create(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rateLimiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认就是 1</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> acquire = limiter.acquire(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前时间 - "</span> + LocalDateTime.now() + <span class="string">" - "</span> + Thread.currentThread().getName() + <span class="string">" - 阻塞 - "</span> + acquire + <span class="string">" 通过..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDemo1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            service.execute(<span class="keyword">this</span>::rateLimiter);</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当前时间 - 2020-03-08T15:10:25.091 - pool-1-thread-2 - 阻塞 - 0.0 通过...</span><br><span class="line">当前时间 - 2020-03-08T15:10:25.531 - pool-1-thread-5 - 阻塞 - 0.453466 通过...</span><br><span class="line">当前时间 - 2020-03-08T15:10:26.031 - pool-1-thread-3 - 阻塞 - 0.953454 通过...</span><br><span class="line">当前时间 - 2020-03-08T15:10:26.531 - pool-1-thread-4 - 阻塞 - 1.453354 通过...</span><br><span class="line">当前时间 - 2020-03-08T15:10:27.031 - pool-1-thread-1 - 阻塞 - 1.952553 通过...</span><br></pre></td></tr></table></figure><p>​    在示例代码中，每秒产生了2个令牌，意味着500毫秒会产生一个令牌。</p><p>​    <em>limiter.acquire(num)</em>表示消费了多少个令牌，当桶中有足够的令牌时，则直接返回0，否则阻塞，直到有足够的令牌数才返回，返回的值为阻塞的时间。</p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>​    漏桶算法(token bucket)，其主要的目的是控制数据注入到网络的速率，平滑网络上的突发流量，数据可以以任意速度流入漏桶中。漏桶可以看做是一个带有常量服务时间的单服务器队列，如果漏桶为空，则不需要流出水滴，如果漏桶（包缓存）溢出，那么水滴会被溢出丢弃。</p><blockquote><p>如图所示</p></blockquote><p><img src="https://i.loli.net/2020/03/08/Qw7NeACgumBYnHh.png" alt="token bucket.png"></p><div align=center>漏桶算法</div><p>​    漏桶算法可以通过<strong>信号量</strong>（<em>Semaphore</em>）的方式实现，很好的达到削峰的目的。</p><p>​    <strong>Semaphore</strong>是JDK1.5提供用于限制获取某种资源的线程数量，拥有公平、非公平两种模。公平模式是顺序获取信号，遵循<strong>先进先出</strong>（<em>FIFO</em>）。而非公平模式则是凭本事抢资源，想先进先出？<strong>不存在的</strong>。默认是非公平模式。</p><blockquote><p>示例代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.battcn.limiting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLimiterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数器限流算法（允许将任务放入到缓冲队列）</span></span><br><span class="line"><span class="comment">     * 信号量，用来达到削峰的目的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">semaphoreLimiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列中允许存活的任务个数不能超过 5 个</span></span><br><span class="line">        <span class="keyword">if</span> (semaphore.getQueueLength() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(LocalDateTime.now() + <span class="string">" - "</span> + Thread.currentThread().getName() + <span class="string">" - 拒絕..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(LocalDateTime.now() + <span class="string">" - "</span> + Thread.currentThread().getName() + <span class="string">" - 通过..."</span>);</span><br><span class="line">                <span class="comment">//处理核心逻辑</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSemaphore</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            service.execute(<span class="keyword">this</span>::semaphoreLimiter);</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如示例代码，队列中的任务存活个数就如同是水桶最多能盛装的水量，当超过这个阈值就会丢弃任务…</p><blockquote><p>执行结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2020-03-08T15:17:00.236 - pool-1-thread-3 - 通过...</span><br><span class="line">2020-03-08T15:17:00.237 - pool-1-thread-2 - 通过...</span><br><span class="line">2020-03-08T15:17:00.236 - pool-1-thread-10 - 拒絕...</span><br><span class="line">2020-03-08T15:17:00.237 - pool-1-thread-1 - 通过...</span><br><span class="line">2020-03-08T15:17:02.237 - pool-1-thread-4 - 通过...</span><br><span class="line">2020-03-08T15:17:02.237 - pool-1-thread-5 - 通过...</span><br><span class="line">2020-03-08T15:17:02.237 - pool-1-thread-6 - 通过...</span><br><span class="line">2020-03-08T15:17:04.238 - pool-1-thread-9 - 通过...</span><br><span class="line">2020-03-08T15:17:04.238 - pool-1-thread-7 - 通过...</span><br><span class="line">2020-03-08T15:17:04.238 - pool-1-thread-8 - 通过...</span><br></pre></td></tr></table></figure><p>​    一共10个线程同时请求，初始信号量为3，表示最多可以同时处理3个任务，超出进入缓存区排队等待，当缓存区满了则拒绝接受新的请求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    本篇文章主要是介绍了几种限流的算法，以上的一些做法其实还是针对本地限流的方案，到了分布式的环境中就凉了，接下的章节中，我也介绍一些在实际项目中怎么来实现限流，以及在分布式中怎么来进行限流。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流。那么何为限流呢？通俗的解释：限流就是限制流量，这就好比移动每个月送你1G的流量， 用完就就没有了！通过限流，我们可以很好的控制系统的QPS，从而达到保护系统的目的，本篇作为限流那些事开篇， 将会介绍一些常用的限流算法以及各自的特点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="限流那些事" scheme="https://blog.chihw.cn/categories/%E9%99%90%E6%B5%81%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    
    
      <category term="web" scheme="https://blog.chihw.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>如何使用el-table进行动态渲染</title>
    <link href="https://blog.chihw.cn/2020/03/07/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8el-table%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93/"/>
    <id>https://blog.chihw.cn/2020/03/07/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8el-table%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93/</id>
    <published>2020-03-07T06:37:48.153Z</published>
    <updated>2020-03-08T14:10:24.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在日常工作中， 经常会碰到表头字段不确定的情况，表头显示的字段名称需要根据后端接口的返回来动态渲染，这时候我们应该怎么处理了，本文将跟大家分享一下，如何使用el-table来进行动态渲染！</p><hr><a id="more"></a><p>​    首先，我们来看一下想要实现的效果。</p><blockquote><p>如图所示</p></blockquote><p><img src="https://i.loli.net/2020/03/07/pw4glkN8CWQydr5.png" alt="微信截图_20200307170707.png"></p><div align="center"> 效果一 </div><p><img src="https://i.loli.net/2020/03/07/mEQJr3FBwGLUcb2.png" alt="微信截图_20200307170840.png"></p><div align="center"> 效果二 </div><p>​    如上两张图可以发现， 表头部分是不确定的， 表头字段是根据接口的返回值来显示，而且表头的上半部分是不确定的，如统计的日期， 但是下半部分又是确定，如（本期，同期，同比）。</p><h3 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h3><p>​    首先需要实现这种效果我们先是要用到<strong>el-table-column</strong>的嵌套使用。</p><blockquote><p>示例代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column v-for&#x3D;&quot;(item,key1) in tablehead.labels&quot; align&#x3D;&quot;center&quot; :key&#x3D;&quot;key1&quot; :label&#x3D;&quot;item.name&quot;&gt;</span><br><span class="line">        &lt;el-table-column v-for&#x3D;&quot;(value,key) in item.children&quot; align&#x3D;&quot;center&quot; :prop&#x3D;&quot;value.prop&quot; :key&#x3D;&quot;key&quot; :formatter&#x3D;&quot;nullFormatter&quot;</span><br><span class="line">          :label-class-name&#x3D;&quot;value.prop&quot; :label&#x3D;&quot;value.name&quot; :id&#x3D;&quot;key&quot;&gt;</span><br><span class="line">        &lt;&#x2F;el-table-column&gt;</span><br><span class="line">&lt;&#x2F;el-table-column&gt;</span><br></pre></td></tr></table></figure><h3 id="后端接口"><a href="#后端接口" class="headerlink" title="后端接口"></a>后端接口</h3><blockquote><p>数据结构</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"labels"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"2020-03-09"</span>,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"本期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KCurrPeriod2"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KLastPeriod2"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同比"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KYoy2"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"2020-03-10"</span>,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"本期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KCurrPeriod3"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KLastPeriod3"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同比"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KYoy3"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"2020-03-11"</span>,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"本期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KCurrPeriod4"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KLastPeriod4"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同比"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KYoy4"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"2020-03-12"</span>,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"本期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KCurrPeriod5"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同期"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KLastPeriod5"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"同比"</span>,</span><br><span class="line">                        <span class="attr">"prop"</span>: <span class="string">"KYoy5"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"datas"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">             </span><br><span class="line">                <span class="attr">"KCurrPeriod4"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KCurrPeriod5"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KCurrPeriod2"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KCurrPeriod3"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KYoy3"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KYoy2"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KYoy5"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KYoy4"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KLastPeriod4"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KLastPeriod5"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KLastPeriod2"</span>: <span class="string">"-"</span>,</span><br><span class="line">                <span class="attr">"KLastPeriod3"</span>: <span class="string">"-"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    对比数据结构可以发现， 后端接口返回的格式也必须要以特定的格式，<strong>labels</strong>部分用来生成对应的表头字段，<strong>datas</strong>部分对应的就是数据。</p><p><img src="https://i.loli.net/2020/03/07/UOm8ZGnrvhcAXk3.png" alt="微信截图_20200307173659.png"><br>    如上所标识的，<strong>labels</strong>中的<strong>prop</strong>值需要跟<strong>datas</strong>中的<strong>key</strong>保持一致， 这样就可以进行动态渲染了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    动态渲染可能在日常工作中还是比较常见的需求，通过上述代码，对于前端来说实现起来动态渲染还是比较简单的， 其实主要还是后端接口格式要好好设计，所以其实这个艰巨的任务要交给后端的小伙伴了（嘻嘻，后端的小伙伴不要打哦！）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    在日常工作中， 经常会碰到表头字段不确定的情况，表头显示的字段名称需要根据后端接口的返回来动态渲染，这时候我们应该怎么处理了，本文将跟大家分享一下，如何使用el-table来进行动态渲染！&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="前端那些事" scheme="https://blog.chihw.cn/categories/%E5%89%8D%E7%AB%AF%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    
    
      <category term="element-ui" scheme="https://blog.chihw.cn/tags/element-ui/"/>
    
      <category term="vue" scheme="https://blog.chihw.cn/tags/vue/"/>
    
  </entry>
  
</feed>
